//---- INCLUDES ---------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include "platform.h"
#include "qspi_flash.h"
#include "xil_printf.h"
#include "xhwicap.h"
#include "xparameters.h"
#include "xil_exception.h"
#include "xintc.h"
#include <string.h>
#include "xspi.h"
#include "xintc.h"
#include <ctype.h>
#include "xil_types.h"
#include "xil_cache.h"


//---- DEFINES ----------------------------------------------------------------

#define HWICAP_EXAMPLE_BITSTREAM_LENGTH     8
u8 BUFFER_CHECK[550];
u8 BUFFER_WRITE[550];

// Commands for the Firmware Update controller
#define FWU_NOP					0x00000000
#define FWU_ERASE_SECTOR		0xffff0000
#define FWU_FLASH_TEST			0x22222222
#define FWU_PROGRAM_PAGE		0xffff2222
#define FWU_READ_PAGE			0xffff3333
#define FWU_BOOT				0xffb001ee

// Location of RAM contents for message passing
#define SHAMEM_PENDING_CMD 		0
#define SHAMEM_CMD_ARGUMENT_1	1
#define SHAMEM_CMD_ARGUMENT_2	2
#define SHAMEM_CMD_STATUS		3
#define SHAMEM_CMD_RESULT		4
#define SHAMEM_CFG_PAGE_SIZE	5
#define SHAMEM_CFG_SECTOR_SIZE	6
#define SHAMEM_WATERMARK		7
#define SHAMEM_FIRST_BYTE		8

// Force an FPGA reboot at the desired address (physical address within the Flash)
void ForceRebootICAP(u32 address);

// Perform a simple Erase/Write/Read test on both Flashes
void FwUpdateRunFlashTest(XSpi *spi, uint32_t StartAddr);

uint32_t FwUpdateProgramPage(XSpi *spi, uint32_t StartAddr, uint32_t NumOfPages);

// Setup interrupts and connect the SPI device
int SetupInterruptSystem(XIntc *IntcPtr, XSpi *SpiPtr);

// From the SPI library
volatile int ErrorCount;
volatile int TransferInProgress;
volatile u8 ReadBuffer[1024];
volatile u8 WriteBuffer[1024];

// Utilities
#define CFG_MEM_WRITE(index, data) \
	Xil_Out32(XPAR_AXI_BRAM_CTRL_1_S_AXI_BASEADDR + (index * 4), data)

#define CFG_MEM_READ(index) \
	Xil_In32(XPAR_AXI_BRAM_CTRL_1_S_AXI_BASEADDR + (index * 4))

XSpi Spi;
XSpi_Config* SpiCfg;
XHwIcap icap;
XHwIcap_Config icap_config;

// Flash device configuration
uint32_t PAGE_SIZE;
uint32_t BYTE_PER_SECTOR;

int main()
{
	int Status;
	//XGpio Gpio;
    uint32_t cmd;
	XIntc InterruptController;
	uint32_t temp_data;
	uint32_t temp_addr;

    xil_printf("--------------------------------------------\n\r");
    xil_printf("---- NUCLEAR INSTRUMENTS OPEN HARDWARE BOOTLOADER\n\r");
    xil_printf("--------------------------------------------\n\r");

	// Preamble
    xil_printf("info: Initializing platform\n\r");

    // Initialize platform
	init_platform();

	// Initialize ICAP device
	XHwIcap_CfgInitialize(&icap, &icap_config, XPAR_AXI_HWICAP_0_BASEADDR);
	XHwIcap_GetConfigReg(&icap, 22, &Status);
	if(Status != 1) {
		xil_printf("erro: Something went wrong\n\r");
		return XST_FAILURE;
	}

	// Initialize SPI device
    xil_printf("info: Initializing SPI device\n\r");
	SpiCfg = XSpi_LookupConfig(XPAR_AXI_QUAD_SPI_0_DEVICE_ID);
	if(SpiCfg == NULL) {
		return XST_DEVICE_NOT_FOUND;
	}

	// Configure SPI device
	Status = XSpi_CfgInitialize(&Spi, SpiCfg, SpiCfg->BaseAddress);

	// Initialize interrupts
	Status = SetupInterruptSystem(&InterruptController, &Spi);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	XSpi_SetStatusHandler(&Spi, &Spi, (XSpi_StatusHandler)SpiHandler);

	Status = XSpi_SetOptions(&Spi, XSP_MASTER_OPTION | XSP_MANUAL_SSELECT_OPTION);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Start SPI controller driver
	XSpi_Start(&Spi);

	// Initialize Flashes
	XSpi_SetSlaveSelect(&Spi, 1);
	SpiFlashQuadEnable(&Spi);
	SpiFlashWriteEnable(&Spi);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// All SPI devices are initialized
    xil_printf("info: SPI device initialization finished\n\r");

 	// Mark the end of the Control section
    CFG_MEM_WRITE(SHAMEM_WATERMARK, 0xdeadbeef);

    // Read Flash configuration
    PAGE_SIZE = CFG_MEM_READ(SHAMEM_CFG_PAGE_SIZE);
    BYTE_PER_SECTOR = CFG_MEM_READ(SHAMEM_CFG_SECTOR_SIZE);

    // Sanity checks
    if(PAGE_SIZE == 0 || BYTE_PER_SECTOR == 0) {
    	xil_printf("erro: Page size and sector size shall be defined before proceeding\n\r");
    	return XST_FAILURE;
    }

    // Control loop will wait for any pending command
	while(1) {
		cmd = CFG_MEM_READ(SHAMEM_PENDING_CMD);

     	switch(cmd) {
     		case FWU_NOP :
     			break;

     		case FWU_ERASE_SECTOR :
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0);

     			// Read address to erase
 				temp_addr = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_1);
 				// Read number of sectors to erase
 				temp_data = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_2);

 				// Erase selected sectors starting at given address
 				QSpiFlashSectorErase(&Spi, temp_addr, temp_data);

 				CFG_MEM_WRITE(SHAMEM_PENDING_CMD, 0);
 	 	 		CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 1);
     			break;

     		case FWU_FLASH_TEST :
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0);

     			// Read test base address
 				temp_data = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_1);

 				// Run test
 				FwUpdateRunFlashTest(&Spi, temp_data);

 		     	CFG_MEM_WRITE(SHAMEM_PENDING_CMD, 0);
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 1);
 				break;

     		case FWU_PROGRAM_PAGE :
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0);

     			// Read starting address
 				temp_addr = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_1);
 				// Read number of pages to program
 				temp_data = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_2);

 				// Program one page at a time
 				temp_data = FwUpdateProgramPage(&Spi, temp_addr, temp_data);
 				CFG_MEM_WRITE(SHAMEM_CMD_RESULT, temp_data);

 				CFG_MEM_WRITE(SHAMEM_PENDING_CMD, 0);
 	 	 		CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 1);
     			break;

     		case FWU_READ_PAGE :
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0);

     			// Read starting address
 				temp_addr = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_1);

 				// Read one page at a time
 				QSpiFlashReadout(&Spi, temp_addr, PAGE_SIZE, ReadBuffer);

 				CFG_MEM_WRITE(SHAMEM_PENDING_CMD, 0);
 	 	 		CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 1);
     			break;

     		case FWU_BOOT :
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0);

     			// Read boot address
     			temp_addr = CFG_MEM_READ(SHAMEM_CMD_ARGUMENT_1);
     			ForceRebootICAP(temp_addr);

 				CFG_MEM_WRITE(SHAMEM_PENDING_CMD, 0);
     			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 1);
     			break;

 	 		default :
 	 			// Unsupported command, inform the user and do not reset the
 	 			// pending command
 	 			CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0xdeadbeef);
 	 			break;
     	}//end_switch(cmd)
     }//end_while(1)

 	// Shall never reach this point
 	xil_printf("erro: Unexpected behavior @[%s:L%d]\r\n", __FILE__, __LINE__);
 	CFG_MEM_WRITE(SHAMEM_CMD_STATUS, 0xdeadbeef);
 	while(1) { }

 	cleanup_platform();
    return XST_FAILURE;
}

uint32_t FwUpdateProgramPage(XSpi *spi, uint32_t StartAddr, uint32_t NumOfPages)
{
	unsigned char *data_buffer;
	unsigned char *source_ptr;

	// Prepare data buffer
	data_buffer = malloc(PAGE_SIZE * sizeof(unsigned char));
	if(data_buffer == NULL) {
		return XST_FAILURE;
	}

	for(uint32_t pdx = 0; pdx < NumOfPages; pdx++) {
		// Point to the first Byte
		source_ptr = (unsigned char *)(XPAR_AXI_BRAM_CTRL_1_S_AXI_BASEADDR + SHAMEM_FIRST_BYTE + (pdx * PAGE_SIZE / 4));

		// Copy data from BRAM to local buffer
		memcpy(data_buffer, source_ptr, PAGE_SIZE);

		// Download data to Flash
		DownloadSerialDataToQSPIFlash(spi, StartAddr, PAGE_SIZE, data_buffer);
	}//end_for(pdx)

	free(data_buffer);
	return XST_SUCCESS;
}

void FwUpdateRunFlashTest(XSpi *spi, uint32_t StartAddr)
{
	// Data buffer
	unsigned char *data_buffer;
	uint32_t temp_data;

	data_buffer = (unsigned char *)malloc(PAGE_SIZE * sizeof(unsigned char));
	for(int bdx = 0; bdx < PAGE_SIZE; bdx++) {
		data_buffer[bdx] = bdx;
	}

	// Reset the result vector
	CFG_MEM_WRITE(SHAMEM_CMD_RESULT, 0);

	// Write to NOR Flash can happen only after an Erase
	XSpi_SetSlaveSelect(spi, 1);

	// Erase entire sector
	if(QSpiFlashSectorErase(spi, StartAddr, 1) != XST_SUCCESS) {
		return XST_FAILURE;
	}
	temp_data = CFG_MEM_READ(SHAMEM_CMD_STATUS) | 0x00000010;
	CFG_MEM_WRITE(SHAMEM_CMD_STATUS, temp_data);

	QSpiFlashReadout(spi, StartAddr, PAGE_SIZE, ReadBuffer);
	temp_data = CFG_MEM_READ(SHAMEM_CMD_STATUS) | 0x00000100;
	CFG_MEM_WRITE(SHAMEM_CMD_STATUS, temp_data);

	// After an Erase command, the target page shall contain all 1's
	temp_data = 0;
	for(int bdx = 0; bdx < PAGE_SIZE; bdx++) {
		temp_data += (ReadBuffer[bdx] == 0xff ? 0 : 1);
	}
	CFG_MEM_WRITE(SHAMEM_CMD_RESULT, temp_data);

	DownloadSerialDataToQSPIFlash(spi, StartAddr, PAGE_SIZE, data_buffer);
	temp_data = CFG_MEM_READ(SHAMEM_CMD_STATUS) | 0x00001000;
	CFG_MEM_WRITE(SHAMEM_CMD_STATUS, temp_data);

	QSpiFlashReadout(spi, StartAddr, PAGE_SIZE, ReadBuffer);
	temp_data = CFG_MEM_READ(SHAMEM_CMD_STATUS) | 0x00010000;
	CFG_MEM_WRITE(SHAMEM_CMD_STATUS, temp_data);

	// After a Program command, the target page shall contain valid data
	temp_data = 0;
	for(int bdx = 0; bdx < PAGE_SIZE; bdx++) {
		temp_data += (ReadBuffer[bdx] == data_buffer[bdx] ? 0 : 1);
	}
	CFG_MEM_WRITE(SHAMEM_CMD_RESULT, temp_data);

	free(data_buffer);
}

int SetupInterruptSystem(XIntc *IntcPtr, XSpi *SpiPtr)
{

	int Status;

	// Register interrupts
	Status = XIntc_Initialize(IntcPtr, XPAR_UBLAZE_HIER_MICROBLAZE_0_AXI_INTC_DEVICE_ID);
	if(Status == XST_DEVICE_NOT_FOUND) {
		return Status;
	}

	// Connect SPI source
	Status = XIntc_Connect(IntcPtr, XPAR_INTC_0_SPI_0_VEC_ID, (XInterruptHandler)XSpi_InterruptHandler, SpiPtr);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Start interrupt controller
	Status = XIntc_Start(IntcPtr, XIN_REAL_MODE);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Enable interrupt source
	XIntc_Enable(IntcPtr, XPAR_INTC_0_SPI_0_VEC_ID);

	// Init
	Xil_ExceptionInit();

	// Register handler
	Xil_ExceptionRegisterHandler(XPAR_INTC_0_SPI_0_VEC_ID, (Xil_ExceptionHandler)XIntc_InterruptHandler, IntcPtr);

	// Enable
	Xil_ExceptionEnable();

	return XST_SUCCESS;
}

void ForceRebootICAP(u32 address)
{
	u32 Index;

	// Taken from IPROG Using ICAPE section in Chapter 11 of UG570
	u32 iprog_data [HWICAP_EXAMPLE_BITSTREAM_LENGTH] =
	{
	        0xFFFFFFFF, /* @0 Dummy Word */
	        0xAA995566, /* @1 Sync Word */
	        0x20000000, /* @2 Type 1 NOOP */
	        0x30020001, /* @3 Type 1 Write 1 words to WBSTAR */
	        0x00000000, /* @4 Warm boot start address (Load the desired address) */
	        0x30008001, /* @5 Type 1 Write 1 words to CMD */
	        0x0000000F, /* @6 IPROG command */
	        0x20000000  /* @7 Type 1 NOOP  */
	};

	//??while(Index > XHwIcap_ReadReg(XPAR_AXI_HWICAP_0_BASEADDR, XHI_WFV_OFFSET));

	// Update WBSTAR with desired one
	iprog_data[4] = address ;
	for(Index = 0; Index < HWICAP_EXAMPLE_BITSTREAM_LENGTH; Index++) {
                XHwIcap_WriteReg(XPAR_AXI_HWICAP_0_BASEADDR, XHI_WF_OFFSET, iprog_data[Index]);
	}

    XHwIcap_WriteReg(XPAR_AXI_HWICAP_0_BASEADDR, XHI_CR_OFFSET, XHI_CR_WRITE_MASK);

	 while ((XHwIcap_ReadReg(HWICAP_EXAMPLE_BITSTREAM_LENGTH,XHI_CR_OFFSET)) & XHI_CR_WRITE_MASK);

	 while (((XHwIcap_ReadReg(HWICAP_EXAMPLE_BITSTREAM_LENGTH, XHI_SR_OFFSET) & XHI_SR_DONE_MASK) ? 0 : 1) != 0);
	 while (XHwIcap_ReadReg(HWICAP_EXAMPLE_BITSTREAM_LENGTH, XHI_CR_OFFSET) & XHI_CR_WRITE_MASK);
}
